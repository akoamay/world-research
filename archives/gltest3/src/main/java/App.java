import org.lwjgl.BufferUtils;
import org.lwjgl.LWJGLException;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;
import org.lwjgl.util.glu.GLU;
import org.newdawn.slick.opengl.Texture;
import org.newdawn.slick.opengl.TextureLoader;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL15.*;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;

import javax.imageio.ImageIO;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {

    int wl = 4;
    Texture texture;
    float px,py,pz;
    float pdx,pdy,pdz;
    float pmx, pmy, pmz;

    float smx, smz;
    float ssmx, ssmz;
    int tick;

    int vss = 32;
    float bs = 4;

    float aang;

    float ofx;
    float ofz;

    float th_o;

    float oox;
    float ooz;

    float opx;
    float opz;

    float tox;
    float toz;


    VoxelSet[] vs;
    float rx = 0.0f, ry = 0.0f, rz = 0.0f;

    int idx[] = new int[wl*wl];

    float height = 50;

    public String getGreeting() {
        return "Hello world.";
    }

    public App(){
       try {
            Display.setDisplayMode(new DisplayMode(1200, 800));
            Display.setTitle("Episode 3 - OpenGL Rendering");
            Display.create();
        } catch (LWJGLException e) {
            e.printStackTrace();
            Display.destroy();
            System.exit(1);
        }

        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        glFrustum(-1,1,-1,1,1,1000);

        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        GLU.gluLookAt(0.0f, 10.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.2f, 0.0f, 0.2f);

        glEnable(GL_TEXTURE_2D);
        glEnable(GL_CULL_FACE); 
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_ALPHA_TEST);

        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);  
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        FloatBuffer blue = BufferUtils.createFloatBuffer(4);
        blue.put(new float[]{0.5f, 0.6f, 1.0f, 1.0f}).flip();
        
        /*
        glEnable(GL_FOG);
        glFog(GL_FOG_COLOR , blue);
        glFogf(GL_FOG_DENSITY, 0.5f);
        glFogi(GL_FOG_MODE , GL_LINEAR);
        glFogi(GL_FOG_START , 10 );
        glFogi(GL_FOG_END , 40);
        */

        /*
        glTranslatef(0.0f, 0.0f, -10.0f);
        glRotatef(90.0f, 1.0f, 0.0f, 0.0f);
        */

        /*
        glRotatef(90.0f, 1.0f, 0.0f, 0.0f);
        glTranslatef(0.0f, -20.0f, 0.0f);
        glScalef(0.02f, 0.02f, 0.02f);
        */

        FloatBuffer pos = BufferUtils.createFloatBuffer(4);
        pos.put( new float[]{0.0f,200.0f, 0.0f,1.0f} ).flip();
        glLight(GL_LIGHT0, GL_POSITION, pos );

        texture = loadTexture();

        vs = new VoxelSet[wl*wl];
        for (int i = 0; i< wl; i++){
            for (int j = 0; j< wl; j++){
                vs[i*wl+j] = new VoxelSet(i,bs,vss,vss,2);
                idx[i*wl+j] = i*wl+j;
            }
        }

        px = 0.0f;
        py = 0.0f;
        pz = 0.0f;

        pdx = 0.0f;
        pdy = 0.0f;
        pdz = 0.0f;

        pmx = 0.0f;
        pmy = 0.0f;
        pmz = 0.0f;

        smx = 0.0f;
        smz = 0.0f;
        ssmx = 0.0f;
        ssmz = 0.0f;

        ofx = 0.0f;
        ofz = 0.0f;

        oox = 0.0f;
        ooz = 0.0f;

        th_o = 0.0f;
        float dth = 0.0f;

        boolean ymove = false;
        boolean tmove = false;

        while (!Display.isCloseRequested()) {

            glClearColor(0.5f, 0.6f, 1.0f, 1.0f);;

            glDepthMask(true);
            glClear(GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER_BIT);

            glLoadIdentity();

            float the = (float)(ry*Math.PI/180);
            float thx = (float)(Math.cos( rx*Math.PI/180 ) );
            float ax = (float)(Math.sin(the));
            float az = (float)(Math.cos(the));
            float apdx = (float)(px*Math.cos(the)-pz*Math.sin(the));
            float apdz = (float)(px*Math.sin(the)+pz*Math.cos(the));
//            glRotatef(ry,0.0f,1.0f,0f);
//            GLU.gluLookAt(apdx, height, -apdz, apdx, 0.0f, -apdz, ax, 0.0f, az);

            glRotatef(90.0f, 1.0f, 0.0f, 0.0f);
            glTranslatef(0.0f, -150.0f, 0.0f);
//        glScalef(0.04f, 0.04f, 0.04f);
        /*
            glRotatef(90,1.0f,0.0f,0f);
            
            //glTranslatef(0, -20.0f, 0);
            glScalef(0.2f, 0.2f, 0.2f);
            */
            glRotatef(rx,-1.0f,0.0f,0f);

            /*
            float th = (float)(Math.PI * ry / 180.0f);
            ofx = -px-(float)( -px*Math.cos(th) + pz*Math.sin(th) );
            ofz = -pz-(float)( -px*Math.sin(th) - pz*Math.cos(th) );
            */

            //glTranslatef(px+ofx+oox, 0, -(pz+ofz+ooz));
            glTranslatef(px+ofx+oox, 0, -(pz+ofz+ooz));
            glRotatef(ry,0f,1f,0f);

            //glTranslatef(apdx-ax, 0, az-apdz);

            if ( Mouse.next() ){
                if (!Mouse.getEventButtonState()){
                    if ( Mouse.getEventButton() == 0 ){
                        if ( ymove ){
                            System.out.println( "ofx=" + ofx + ",oox=" + oox  );
                            //ymove = toggley(false, ymove );
                        }
                    }
                }
            }

            if ( Mouse.isButtonDown(0)){
                int dx = Mouse.getDX();
                int dy = Mouse.getDY();
                if ( Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) ){
                    if ( dx != 0 ){
                        //glTranslatef(smx, 0, -smz);
                        ry+=dx;

                        ymove = toggley(true, ymove );
                        tmove = togglem(false, tmove);

                        float dox = opx+oox;
                        float doz = opz+ooz;

                        dth = (float)(Math.PI*ry/180.0f) - th_o;
                        //ofx = -opx-(float)( -opx*Math.cos(dth) + opz*Math.sin(dth) );
                        //ofz = -opz-(float)( -opx*Math.sin(dth) - opz*Math.cos(dth) );
                        ofx = -dox-(float)( -dox*Math.cos(dth) + doz*Math.sin(dth) );
                        ofz = -doz-(float)( -dox*Math.sin(dth) - doz*Math.cos(dth) );
                    }else{
                        if ( dy != 0 ) rx+=dy;
                    }
                }else{
                    if (dx!=0 || dy != 0 ){
                        float ddx = (float)dx/10.0f;
                        float ddy = (float)dy/10.0f;
                        px+=ddx;
                        pz+=ddy;
                        opx += ddx;
                        opz += ddy;
                        tmove = togglem(true, tmove);
                    }
                    ymove = toggley(false, ymove);
                }
            }


            int dw = Mouse.getDWheel();
            if ( dw != 0 ){
                if ( dw > 0 ){
                    height *= 1.1f;
                }else{
                    height *= 0.9f;
                }
            }


            glDisable(GL_BLEND);
            glAlphaFunc(GL_EQUAL, 1.0f);
            render();

            glEnable(GL_BLEND);
            glDepthMask(false);
            glAlphaFunc(GL_LESS, 1.0f);
            render();
            
            Display.update();
            Display.sync(60);
        }
        Display.destroy();
        System.exit(0);
    }

    public boolean togglem( boolean flg, boolean tmove){
        if ( !flg ){
            if ( tmove ){
                System.out.println( "togglem off" );
                return false;
            }
            return false;
        }else{
            if ( !tmove ){
                System.out.println( "togglem on" );
//                opx = 0f;
 //               opz = 0f;
                return true;
            }
            return true;
        }
    }
    public boolean toggley( boolean flg, boolean ymove){
        if ( !flg ){
            if ( ymove ){ 
                th_o = (float)(Math.PI*ry/180.0f);
                oox += ofx;
                ooz += ofz;
                ofx = 0.0f;
                ofz = 0.0f;
                System.out.println( "toggley off" );
                return false;
            }
            return false;
        }else{
            if ( !ymove ){ 
                System.out.println( "toggley on" );
                return true;
            }
            return true;
        }
    }

    private void render(){
        for (int i = 0; i< wl*wl; i++){
            float o = ( 1/2.0f - wl/2.0f ) * vss * bs;

            int j = idx[i];
            float xx = o + i%wl * vss * bs;
            float zz = o + i/wl * vss * bs;

            glPushMatrix();

            glTranslatef(xx,0,zz);

            vs[j].render( texture.getTextureID());
            glPopMatrix();

        }

    }

    public static void main(String[] args) {
        new App();
    }

	private Texture loadTexture() {
		try {
			return TextureLoader.getTexture("PNG", new FileInputStream(new File("tile.png")));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
