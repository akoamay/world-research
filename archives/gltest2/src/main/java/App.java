import org.lwjgl.BufferUtils;
import org.lwjgl.LWJGLException;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;
import org.lwjgl.util.glu.GLU;
import org.newdawn.slick.opengl.Texture;
import org.newdawn.slick.opengl.TextureLoader;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL15.*;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;

import javax.imageio.ImageIO;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {

    int wl = 16;
    Texture texture;
    float px,py,pz;
    float pdx,pdy,pdz;
    float pmx, pmy, pmz;

    float smx, smz;
    float ssmx, ssmz;
    int tick;

    int vss = 1;
    float bs = 4;

    float aang;

    float ofx;
    float ofz;

    float th_o;


    VoxelSet[] vs;
    float rx = 0.0f, ry = 0.0f, rz = 0.0f;

    int idx[] = new int[wl*wl];

    float height = 50;

    public String getGreeting() {
        return "Hello world.";
    }

    public App(){
       try {
            Display.setDisplayMode(new DisplayMode(900, 600));
            Display.setTitle("Episode 3 - OpenGL Rendering");
            Display.create();
        } catch (LWJGLException e) {
            e.printStackTrace();
            Display.destroy();
            System.exit(1);
        }

        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        glFrustum(-1,1,-1,1,1,1000);

        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        GLU.gluLookAt(0.0f, 10.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.2f, 0.0f, 0.2f);

        glEnable(GL_TEXTURE_2D);
        glEnable(GL_CULL_FACE); 
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_ALPHA_TEST);

        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);  
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        FloatBuffer blue = BufferUtils.createFloatBuffer(4);
        blue.put(new float[]{0.5f, 0.6f, 1.0f, 1.0f}).flip();
        
        /*
        glEnable(GL_FOG);
        glFog(GL_FOG_COLOR , blue);
        glFogf(GL_FOG_DENSITY, 0.5f);
        glFogi(GL_FOG_MODE , GL_LINEAR);
        glFogi(GL_FOG_START , 10 );
        glFogi(GL_FOG_END , 40);
        */

        /*
        glTranslatef(0.0f, 0.0f, -10.0f);
        glRotatef(90.0f, 1.0f, 0.0f, 0.0f);
        */

       // glRotatef(90.0f, 1.0f, 0.0f, 0.0f);
        //glTranslatef(0.0f, -20.0f, 0.0f);
        glScalef(0.02f, 0.02f, 0.02f);

        FloatBuffer pos = BufferUtils.createFloatBuffer(4);
        pos.put( new float[]{0.0f,200.0f, 0.0f,1.0f} ).flip();
        glLight(GL_LIGHT0, GL_POSITION, pos );

        texture = loadTexture();

        vs = new VoxelSet[wl*wl];
        for (int i = 0; i< wl; i++){
            for (int j = 0; j< wl; j++){
                vs[i*wl+j] = new VoxelSet(i,bs,vss,vss,4);
                idx[i*wl+j] = i*wl+j;
            }
        }


        px = 0.0f;
        py = 0.0f;
        pz = 0.0f;

        pdx = 0.0f;
        pdy = 0.0f;
        pdz = 0.0f;

        pmx = 0.0f;
        pmy = 0.0f;
        pmz = 0.0f;

        smx = 0.0f;
        smz = 0.0f;
        ssmx = 0.0f;
        ssmz = 0.0f;

        ofx = 0.0f;
        ofz = 0.0f;

        th_o = 0.0f;


        while (!Display.isCloseRequested()) {

            glClearColor(0.5f, 0.6f, 1.0f, 1.0f);;

            glDepthMask(true);
            glClear(GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER_BIT);

        glLoadIdentity();
        float the = (float)(ry*Math.PI/180);
        float thx = (float)(Math.cos( rx*Math.PI/180 ) );
        float ax = (float)(Math.sin(the));
        float az = (float)(Math.cos(the));
        float apdx = (float)(px*Math.cos(the)-pz*Math.sin(the));
        float apdz = (float)(px*Math.sin(the)+pz*Math.cos(the));
        GLU.gluLookAt(apdx, height, -apdz, apdx, 0.0f, -apdz, ax, 0.0f, az);

//        glTranslatef( apdx-px, 0.0f, -(apdz-pz) );


            if ( Keyboard.isKeyDown(Keyboard.KEY_0) ){
                //ry = 90;
                //GLU.gluLookAt(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz);
            }


            if ( Mouse.next() ){
                if (!Mouse.getEventButtonState()){
                    if ( Mouse.getEventButton() == 0 ){
                        float th = (float)(ry*Math.PI/180.0f);
                    }
                }
            }

            if ( Mouse.isButtonDown(0)){
                int dx = Mouse.getDX();
                int dy = Mouse.getDY();
            if ( Keyboard.isKeyDown(Keyboard.KEY_1) ){
                dx = 10;
                dy = 0;
            }
                if ( Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) ){


                    if ( dx != 0 ){
                        //glRotatef( (float)dx, 0.0f, 1.0f, 0.0f );


                        ry+=dx;
                        th_o = (float)(ry*Math.PI/180.0f);

                        /*
                        float th = (float)(dx * Math.PI / 180.0f);
                        ofx = (float)(-smx * Math.cos(th) + smz * Math.sin(th) ) - (-smx);
                        ofz = (float)(-smx * Math.sin(th) - smz * Math.cos(th) ) - (-smz);
                        glTranslatef( -ofx, 0.0f, -ofz );
                        */

                        aang += dx;
                    }

                    if ( dy != 0 ){
                   //     glRotatef( (float)dy, -1.0f, 0.0f, 0.0f );
                        /*
                        glRotatef( (float)ry, 0.0f,-1.0f, 0.0f );
                        glRotatef( (float)dy,-1.0f, 0.0f, 0.0f );
                        glRotatef( (float)ry, 0.0f, 1.0f, 0.0f );
                        */
                        rx+=dy;
                    }
                }else{
                    if (dx!=0 || dy != 0 ){


                        float ddx = (float)dx/10.0f;
                        float ddy = (float)dy/10.0f;

                        float ang = (float)(180*Math.atan2(ddy,ddx)/Math.PI);
                        float len = (float)(Math.sqrt(ddx*ddx+ddy*ddy));

                        float tt = ry % 360;
                        float angd = ang - tt;
                        float th = (float)(Math.PI * angd / 180.0f);

                        float sx = (float)(len * Math.cos( th ));
                        float sy = (float)(len * Math.sin( th ));

                        float rt = (float)(Math.PI * tt / 180.0f);


//                        sx = len*Math.cos();


                 //       glTranslatef( ddx, 0.0f, -ddy );
                        //glTranslatef(sx, 0.0f, sy );

                        px+=ddx;
                        pz+=ddy;

                        pdx+=sx;
                        pdz+=sy;

                        pmx += ddx;
                        pmz += ddy;

                        smx += ddx;
                        smz += ddy;

                        if ( -pdz >= bs*vss ){
                            int t[] = new int[wl];
                            for (int i = 0; i < wl; i++ ){
                                for (int j = 0; j < wl; j++ ){
                                    if ( i == 0 ){
                                        t[j] = idx[wl*(wl-1)+j];
                                        idx[wl*(wl-1)+j] = idx[wl*(wl-2)+j];
                                    }else if ( i == wl-1 ){
                                        idx[j] = t[j];
                                    }else{
                                        idx[wl*(wl-1-i)+j] = idx[wl*(wl-2-i)+j];
                                    }
                                }
                            }

                            float ttx = (float)(pdz*Math.sin(rt));
                            float tty = (float)(pdz*Math.cos(rt));
                        //    if ( tt > 0 && tt < 180 ) ttx *= -1;
 //                           if ( tt > 0 && tt < 180 ) tty *= -1;
//                            if ( tt > 180 && tt < 360 ) tty *= -1;

                            glTranslatef(ttx, 0f, tty);


                            //pmx -= tty; pmz = 0;
                            //pz = 0;
                            px -= ttx;
                            pz -= tty;

                            pdz = 0;
                            System.out.println("pz+");
                        };

                       if ( -pdz <= -bs*vss ){
                            int t[] = new int[wl];
                            for (int i = 0; i < wl; i++ ){
                                for (int j = 0; j < wl; j++ ){
                                    if ( i == 0 ){
                                        t[j] = idx[j];
                                        idx[j] = idx[wl+j];
                                    }else if ( i == wl-1 ){
                                        idx[wl*(wl-1)+j] = t[j];
                                    }else{
                                        idx[wl*i+j] = idx[wl*(i+1)+j];
                                    }
                                }
                            }
                            float ttx = (float)(pdz*Math.sin(rt));
                            float tty = (float)(pdz*Math.cos(rt));
                         //   if ( tt > 0 && tt < 180 ) ttx *= -1;
                            //if ( ( th > 0 && th < Math.PI/2.0f ) || ( th > Math.PI && th < ( 3.0f * Math.PI ) / 2.0f ) ) tty *= -1;
 //                           if ( tt > 180 && tt < 360 ) tty *= -1;
                            glTranslatef(ttx, 0f, tty);
                            //pmx -= tty; pmz = 0;

                            px -= ttx;
                            pz -= tty;

                            pdz = 0;
                            System.out.println("pz-");
                        };

                        if ( pdx >= bs*vss ){
                            int t[] = new int[wl];
                            for (int i = 0; i < wl; i++ ){
                                for (int j = 0; j < wl; j++ ){
                                    if ( i == 0 ){
                                        t[j] = idx[wl*j+(wl-1)];
                                        idx[wl*j+(wl-1)] = idx[wl*j+(wl-2)];
                                    }else if ( i == wl-1 ){
                                        idx[wl*j] = t[j];
                                    }else{
                                        idx[wl*j+(wl-i-1)] = idx[wl*j+(wl-i-2)];
                                    }
                                }
                            }

                            float ttx = (float)(pdx*Math.cos(rt));
                            float tty = (float)(pdx*Math.sin(rt));
                          //  if ( ( tt > 0 && tt < 90 ) || ( tt > 180 && tt < 270 ) ) tty *= -1;
  //                          if ( tt > 180 && tt < 360 ) tty *= -1;
                            glTranslatef(-ttx, 0f, tty);

                            /*
                            glTranslatef(-pmx, 0f, pmz );
                            */
                            //pmx = 0; pmz -= tty;
                            px -= ttx;
                            pz -= tty;

                            pdx = 0;
                            System.out.println("px+");
                        };

                       if ( pdx <= -bs*vss ){
                            int t[] = new int[wl];
                            for (int i = 0; i < wl; i++ ){
                                for (int j = 0; j < wl; j++ ){
                                    if ( i == 0 ){
                                        t[j] = idx[wl*j];
                                        idx[wl*j] = idx[wl*j+1];
                                    }else if ( i == wl-1 ){
                                        idx[wl*j+wl-1] = t[j];
                                    }else{
                                        idx[wl*j+i] = idx[wl*j+i+1];
                                    }
                                }
                            }
                            float ttx = (float)(pdx*Math.cos(rt));
                            float tty = (float)(pdx*Math.sin(rt));
                           // if ( ( tt > 0 && tt < 90 ) || ( tt > 180 && tt < 270 ) ) tty *= -1;
                           // if ( ( tt > 0 && tt < 90 ) || ( tt > 180 && tt < 270 ) ) tty *= -1;
                            //if ( ( th > 0 && th < Math.PI/2.0f ) || ( th > Math.PI && th < ( 3.0f * Math.PI ) / 2.0f ) ) tty *= -1;
   //                         if ( tt > 180 && tt < 360 ) tty *= -1;
                            glTranslatef(-ttx, 0f, tty);
                            //glTranslatef(-pmx, 0f, pmz );
                            //pmx = 0; pmz -= tty;

                            px -= ttx;
                            pz -= tty;

                            pdx = 0;
                            System.out.println("px-");
                        };



                    }
                    
                }
            }


            int dw = Mouse.getDWheel();
            if ( dw != 0 ){
                float s;
                if ( dw > 0 ){
                    s = 1.1f;
                    height *= 1.1f;
                }else{
                    s = 0.9f;
                    height *= 0.9f;
                }
                //glRotatef( ry, 0.0f, -1.0f, 0.0f );
                //glTranslatef( -px, 0.0f, pz );
                //glScalef(s, s, s);
                //glTranslatef( px, 0.0f, -pz );
                //glRotatef( ry, 0.0f, 1.0f, 0.0f );
            }



            //System.out.println( "ry=" + ry + "(" + ssmx + "," + ssmz + ")" );

            glDisable(GL_BLEND);
            glAlphaFunc(GL_EQUAL, 1.0f);
            render();

            glEnable(GL_BLEND);
            glDepthMask(false);
            glAlphaFunc(GL_LESS, 1.0f);
            render();
            
            
            //move();

            Display.update();
            Display.sync(60);
        }
        Display.destroy();
        System.exit(0);
    }

    private void move(){

        
//        vs.move();

float x = 0f;
float y = 0f;
float z = 0f;
float u = 1f;


/*

        vertexArray = new float[]{ x-u, y-u, z+u, x+u, y-u, z+u, x+u, y+u, z+u,
           x-u, y+u, z+u, x-u, y-u, z+u, x-u, y+u, z+u, x-u, y+u, z-u, x-u, y-u, z-u };

        FloatBuffer _vertexBuffer = BufferUtils.createFloatBuffer(vertexArray.length);
//        vertexBuffer = BufferUtils.createFloatBuffer(vs.vtxFloatArray.length);
        _vertexBuffer.put(vertexArray).flip();
        facet_num = vertexArray.length/3;

        glBindBuffer(GL_ARRAY_BUFFER, vboVertexHandle);
        glBufferSubData(GL_ARRAY_BUFFER, 0L, _vertexBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, 0);

        */




        /*
        vertexBuffer.rewind();
//        textureBuffer = BufferUtils.createFloatBuffer(vs.texFloatArray.length);
        textureBuffer.put(vs.texFloatArray).flip();
        glBindBuffer(GL_ARRAY_BUFFER, vboTextureHandle);
        glBufferSubData(GL_ARRAY_BUFFER, 0L, textureBuffer );
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        */

        /*
        normalBuffer.clear();
        normalBuffer = BufferUtils.createFloatBuffer(vs.nrmFloatArray.length);
        normalBuffer.put(vs.nrmFloatArray).flip();
        glBindBuffer(GL_ARRAY_BUFFER, vboNormalHandle);
        glBufferSubData(GL_ARRAY_BUFFER, 0L, normalBuffer );
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        */

    }

    private void render(){

        for (int i = 0; i< wl*wl; i++){
            float o = ( 1/2.0f - wl/2.0f ) * vss * bs;

            int j = idx[i];
            float xx = o + i%wl * vss * bs;
            float zz = o + i/wl * vss * bs;


            glPushMatrix();

            /*
                float a = th_o - th;
                */
                float th = (float)(Math.PI * ry / 180.0f) - th_o;
                ssmx = (float)(smx * Math.cos(th) - smz * Math.sin(th) ) - smx;
                ssmz = (float)(smx * Math.sin(th) + smz * Math.cos(th) ) - smz;
             //   glTranslatef( ssmx, 0.0f, -ssmz );

                //glRotatef( ry, 0.0f, 1.0f, 0.0f );

                /*
                float dmx = (float)(pmx * Math.cos(th)-pmz*Math.sin(th));
                float dmz = (float)(pmx * Math.sin(th)+pmz*Math.cos(th));
                float dmx = -px;
                float dmz = pz;
                float ddmx = (float)(dmx * Math.cos(th)-dmz*Math.sin(th));
                float ddmz = (float)(dmx * Math.sin(th)+dmz*Math.cos(th));

            if ( Mouse.isButtonDown(1)){
                System.out.println("dmx="+dmx+",ddmx="+ddmx);
                System.out.println("dmz="+dmz+",ddmz="+ddmz);
            }
                */


                //glTranslatef(-rssmx+ssmx,0,-rssmz+ssmz);
                //glTranslatef(dmx-ddmx,0,dmz-ddmz);
                glTranslatef(xx,0,zz);

                /*
                float alen = (float)Math.sqrt(px*px+pz*pz);
                float rt = (float)(ry*Math.PI/180);
                float art = (float)Math.atan2(pz,px);
                float ax = alen*(float)Math.cos(art-rt);
                float ay = alen*(float)Math.sin(art-rt);
                glTranslatef(-ax,0,ay);
                */

                vs[j].render( texture.getTextureID());
                glPopMatrix();

        }

    }

    public static void main(String[] args) {
        new App();
    }

	private Texture loadTexture() {
		try {
			return TextureLoader.getTexture("PNG", new FileInputStream(new File("tile.png")));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
